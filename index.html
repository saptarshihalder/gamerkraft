<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GamerKraft 3D - Pro Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@500&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; 
            color: white;
            overflow: hidden;
            user-select: none;
        }

        /* Editor Look */
        .panel {
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid #334155;
            backdrop-filter: blur(8px);
        }

        .tool-btn {
            transition: all 0.1s;
        }
        .tool-btn.active {
            background-color: #2563eb;
            color: white;
            border-color: #3b82f6;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 50;
            filter: drop-shadow(0 0 2px black);
        }

        /* Hide UI in exported game */
        body.exported #editor-ui { display: none !important; }
        body.exported #start-screen { display: flex !important; }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col bg-black">

    <!-- EDITOR UI WRAPPER -->
    <div id="editor-ui" class="absolute inset-0 pointer-events-none z-20 flex flex-col">
        
        <!-- Top Menu Bar -->
        <div class="h-12 panel border-b flex items-center justify-between px-4 pointer-events-auto shrink-0">
            <div class="flex items-center gap-4">
                <div class="flex items-center gap-2 text-blue-500">
                    <i data-lucide="box" class="w-5 h-5"></i>
                    <span class="font-black tracking-tight text-white">GAMERKRAFT <span class="text-blue-500 text-xs align-top">PRO</span></span>
                </div>
                <div class="h-4 w-px bg-slate-700"></div>
                <div class="flex bg-slate-800 rounded p-0.5">
                    <button id="modeEdit" onclick="setMode('EDIT')" class="px-3 py-1 text-xs font-bold rounded bg-blue-600 text-white shadow">EDITOR</button>
                    <button id="modePlay" onclick="setMode('PLAY')" class="px-3 py-1 text-xs font-bold rounded text-slate-400 hover:text-white">PLAY</button>
                </div>
            </div>

            <div class="flex items-center gap-2">
                <div id="score-display" class="hidden px-3 py-1 bg-slate-800 rounded text-yellow-400 font-mono text-sm font-bold border border-slate-700">
                    SCORE: <span id="score-val">0</span>
                </div>
                <button onclick="saveWorld()" class="p-1.5 hover:bg-slate-800 rounded text-slate-400 hover:text-white" title="Save Project"><i data-lucide="save" class="w-4 h-4"></i></button>
                <button onclick="document.getElementById('fileInput').click()" class="p-1.5 hover:bg-slate-800 rounded text-slate-400 hover:text-white" title="Load Project"><i data-lucide="folder-open" class="w-4 h-4"></i></button>
                <button onclick="publishGame()" class="flex items-center gap-2 bg-green-600 hover:bg-green-500 text-white px-3 py-1 rounded text-xs font-bold transition-colors shadow">
                    <i data-lucide="rocket" class="w-3 h-3"></i> PUBLISH
                </button>
                <input type="file" id="fileInput" class="hidden" accept=".json" onchange="loadWorld(this)">
            </div>
        </div>

        <div class="flex-1 flex overflow-hidden">
            <!-- Left Sidebar: Tools -->
            <div class="w-16 panel border-r flex flex-col items-center py-4 gap-4 pointer-events-auto">
                <div class="flex flex-col gap-2 w-full px-2">
                    <span class="text-[10px] text-slate-500 font-bold text-center uppercase">Tools</span>
                    <button onclick="setTool('brush')" id="tool-brush" class="tool-btn active w-full aspect-square rounded flex items-center justify-center bg-slate-800 border border-slate-700 text-slate-400 hover:text-white" title="Brush (Single Block)">
                        <i data-lucide="paintbrush" class="w-5 h-5"></i>
                    </button>
                    <button onclick="setTool('box')" id="tool-box" class="tool-btn w-full aspect-square rounded flex items-center justify-center bg-slate-800 border border-slate-700 text-slate-400 hover:text-white" title="Box Fill (Drag to Build)">
                        <i data-lucide="box-select" class="w-5 h-5"></i>
                    </button>
                    <button onclick="setTool('eraser')" id="tool-eraser" class="tool-btn w-full aspect-square rounded flex items-center justify-center bg-slate-800 border border-slate-700 text-slate-400 hover:text-white hover:border-red-500 hover:bg-red-900/20" title="Eraser">
                        <i data-lucide="eraser" class="w-5 h-5"></i>
                    </button>
                </div>
                
                <div class="h-px w-8 bg-slate-700"></div>

                <div class="flex flex-col gap-2 w-full px-2">
                    <span class="text-[10px] text-slate-500 font-bold text-center uppercase">Action</span>
                    <button onclick="clearWorld()" class="w-full aspect-square rounded flex items-center justify-center bg-slate-800 border border-slate-700 text-red-400 hover:bg-red-900/50 hover:text-red-200 transition-colors" title="Clear All">
                        <i data-lucide="trash-2" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>

            <!-- Main Viewport Area (Empty div, canvas is behind) -->
            <div class="flex-1 relative">
                <!-- Hint Overlay -->
                <div id="tool-hint" class="absolute top-4 left-1/2 -translate-x-1/2 bg-black/50 text-white text-xs px-3 py-1 rounded-full backdrop-blur-sm border border-white/10 pointer-events-none">
                    Left Click: Place • Right Click: Remove • Drag: Box Fill
                </div>
            </div>

            <!-- Right Sidebar: Properties (Future expansion) -->
            <!-- For now kept simpler, just the block palette at bottom -->
        </div>

        <!-- Bottom Palette -->
        <div class="h-24 panel border-t p-2 pointer-events-auto shrink-0 flex justify-center">
            <div class="flex gap-2 overflow-x-auto px-2" id="block-palette">
                <!-- Blocks injected here -->
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="hidden absolute inset-0 bg-slate-950 z-50 flex items-center justify-center flex-col">
        <h1 class="text-6xl font-black text-white mb-2 tracking-tight">GAMERKRAFT <span class="text-blue-500">3D</span></h1>
        <button onclick="startExportedGame()" class="mt-8 bg-blue-600 hover:bg-blue-500 text-white px-8 py-3 rounded-full font-bold text-lg shadow-lg transition-transform hover:scale-105">START GAME</button>
    </div>

    <!-- Victory Overlay -->
    <div id="game-overlay" class="hidden absolute inset-0 bg-slate-900/90 backdrop-blur-md z-40 flex items-center justify-center flex-col">
        <h1 id="overlay-title" class="text-6xl font-black mb-4 text-white">VICTORY</h1>
        <p id="overlay-msg" class="text-2xl text-slate-300 mb-8">Score: 0</p>
        <button onclick="resetLevel()" class="bg-white text-slate-900 px-8 py-3 rounded-full font-bold hover:scale-105 transition-transform">TRY AGAIN</button>
    </div>

    <!-- Crosshair -->
    <div id="crosshair">
        <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" class="w-6 h-6 drop-shadow-md">
            <path d="M12 8v8M8 12h8" />
        </svg>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container" class="absolute inset-0 z-0 bg-slate-900 cursor-crosshair"></div>

    <script>
        // --- CONSTANTS ---
        const BLOCKS = [
            { id: 1, name: 'Stone', color: 0x64748b, type: 'solid' },
            { id: 2, name: 'Grass', color: 0x22c55e, type: 'solid' },
            { id: 3, name: 'Dirt', color: 0x78350f, type: 'solid' },
            { id: 4, name: 'Wood', color: 0xa16207, type: 'solid' },
            { id: 5, name: 'Brick', color: 0xb91c1c, type: 'solid' },
            { id: 6, name: 'Glass', color: 0x67e8f9, opacity: 0.4, type: 'solid' },
            { id: 7, name: 'Neon', color: 0xd946ef, type: 'solid', emissive: 0xd946ef },
            // Mechanics
            { id: 10, name: 'Start', color: 0x3b82f6, opacity: 0.5, type: 'spawn' },
            { id: 11, name: 'Goal', color: 0x10b981, type: 'goal' },
            { id: 12, name: 'Coin', color: 0xfacc15, type: 'coin', shape: 'coin' },
            { id: 13, name: 'Spike', color: 0xff0000, type: 'hazard', shape: 'cone' },
            { id: 14, name: 'Jump', color: 0xf472b6, type: 'jumppad' },
            { id: 15, name: 'Speed', color: 0x22d3ee, type: 'speedpad' },
            { id: 16, name: 'Enemy', color: 0x7e22ce, type: 'enemy_spawner', shape: 'skull' },
            { id: 17, name: 'Turret', color: 0x334155, type: 'turret' }
        ];

        let state = {
            mode: 'EDIT', // EDIT | PLAY
            tool: 'brush', // brush | box | eraser
            blockId: 1,
            voxels: {}, // "x,y,z" -> id
            meshes: {},
            items: [],
            entities: [],
            player: { pos: new THREE.Vector3(0,10,0), vel: new THREE.Vector3(), rot: new THREE.Euler(0,0,0,'YXZ'), onGround:false, speed:1, dead:false, won:false },
            drag: { active: false, start: new THREE.Vector3(), end: new THREE.Vector3() },
            score: 0,
            keys: { w:false, a:false, s:false, d:false, space:false, shift:false }
        };

        // --- THREE JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f172a);
        scene.fog = new THREE.Fog(0x0f172a, 30, 90);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Environment
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const sun = new THREE.DirectionalLight(0xffffff, 0.7);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        scene.add(sun);

        // Editor Helpers
        const gridHelper = new THREE.GridHelper(200, 200, 0x1e293b, 0x0f172a);
        scene.add(gridHelper);
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        // Input
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Selection Box (Ghost)
        const ghostGeo = new THREE.BoxGeometry(1,1,1);
        const ghostMat = new THREE.MeshBasicMaterial({ color: 0x3b82f6, opacity: 0.3, transparent: true, depthTest: false });
        const ghost = new THREE.Mesh(ghostGeo, ghostMat);
        scene.add(ghost);
        
        const selectionBox = new THREE.Box3Helper(new THREE.Box3(), 0xffff00);
        scene.add(selectionBox);
        selectionBox.visible = false;

        // --- MESH GENERATION ---
        const boxGeo = new THREE.BoxGeometry(1,1,1);
        const coneGeo = new THREE.ConeGeometry(0.5, 0.8, 4);
        const coinGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16); coinGeo.rotateX(Math.PI/2);
        
        const materials = {};
        BLOCKS.forEach(b => {
            materials[b.id] = new THREE.MeshStandardMaterial({
                color: b.color,
                roughness: 0.6,
                metalness: 0.1,
                transparent: !!b.opacity,
                opacity: b.opacity || 1,
                emissive: b.emissive || 0x000000,
                emissiveIntensity: 0.5
            });
        });

        const enemyMat = new THREE.MeshStandardMaterial({ color: 0xef4444 });
        const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });

        // --- CORE FUNCTIONS ---

        function createBlock(x, y, z, id) {
            const key = `${x},${y},${z}`;
            if(state.voxels[key]) removeBlock(x,y,z); // Replace existing

            const def = BLOCKS.find(b => b.id === id);
            if(!def) return;

            let mesh;
            if(def.shape === 'cone') {
                mesh = new THREE.Mesh(coneGeo, materials[id]);
                mesh.position.set(x+0.5, y+0.4, z+0.5);
            } else if(def.shape === 'coin') {
                mesh = new THREE.Mesh(coinGeo, materials[id]);
                mesh.position.set(x+0.5, y+0.5, z+0.5);
            } else {
                mesh = new THREE.Mesh(boxGeo, materials[id]);
                mesh.position.set(x+0.5, y+0.5, z+0.5);
            }

            if(def.type === 'solid' || def.type === 'jumppad' || def.type === 'speedpad' || def.type === 'turret') {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
            }

            mesh.userData = { x, y, z, id, def, isBlock: true };
            scene.add(mesh);
            state.voxels[key] = id;
            state.meshes[key] = mesh;

            if(['coin','hazard','goal','jumppad','speedpad','enemy_spawner','turret'].includes(def.type)) {
                state.items.push({ mesh, x, y, z, def, active: true });
            }
        }

        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            if(!state.voxels[key]) return;
            
            scene.remove(state.meshes[key]);
            state.meshes[key].geometry.dispose(); // clean memory
            delete state.voxels[key];
            delete state.meshes[key];
            
            state.items = state.items.filter(i => !(i.x === x && i.y === y && i.z === z));
        }

        function clearWorld() {
            Object.keys(state.voxels).forEach(k => {
                const [x,y,z] = k.split(',').map(Number);
                removeBlock(x,y,z);
            });
            // Default Platform
            for(let x=-5; x<5; x++) for(let z=-5; z<5; z++) createBlock(x,0,z, 1);
        }

        // --- TOOLS & INTERACTION ---

        // Palette UI
        const palette = document.getElementById('block-palette');
        BLOCKS.forEach(b => {
            const btn = document.createElement('div');
            btn.className = `flex flex-col items-center gap-1 min-w-[60px] cursor-pointer opacity-70 hover:opacity-100 transition-opacity`;
            btn.innerHTML = `
                <div class="w-10 h-10 rounded border-2 border-slate-600 shadow-md" style="background-color: #${b.color.toString(16).padStart(6,'0')}"></div>
                <span class="text-[9px] font-bold text-slate-400 uppercase tracking-wider">${b.name}</span>
            `;
            btn.onclick = () => {
                state.blockId = b.id;
                state.tool = 'brush'; // Auto switch to brush
                updateUI();
            };
            palette.appendChild(btn);
        });

        function setTool(t) {
            state.tool = t;
            updateUI();
        }

        function updateUI() {
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`tool-${state.tool}`).classList.add('active');
            
            document.getElementById('tool-hint').innerText = 
                state.tool === 'box' ? "Click & Drag to Fill Area" : 
                state.tool === 'eraser' ? "Click or Drag to Erase" : 
                "Left Click to Build • Right Click to Erase";
        }

        // Raycasting Logic
        function getIntersect() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            const hit = intersects.find(i => i.object.userData.isBlock);
            
            if (hit) {
                return { 
                    pos: hit.object.position.clone(), 
                    normal: hit.face.normal,
                    voxel: {
                        x: hit.object.userData.x,
                        y: hit.object.userData.y,
                        z: hit.object.userData.z
                    }
                };
            }
            
            // Ground Plane Logic (y=0)
            const t = -raycaster.ray.origin.y / raycaster.ray.direction.y;
            if (t > 0 && t < 200) {
                const p = new THREE.Vector3().copy(raycaster.ray.origin).add(raycaster.ray.direction.multiplyScalar(t));
                return {
                    pos: p,
                    normal: new THREE.Vector3(0,1,0),
                    voxel: {
                        x: Math.floor(p.x),
                        y: 0,
                        z: Math.floor(p.z)
                    }
                };
            }
            return null;
        }

        // Mouse Events
        document.addEventListener('mousedown', e => {
            if(e.target.closest('#editor-ui') || state.mode === 'PLAY') return;
            if(e.button !== 0 && e.button !== 2) return; // Only L/R click

            const hit = getIntersect();
            if(!hit) return;

            if (state.tool === 'box' || (state.tool === 'eraser' && e.button === 0)) {
                // Start Drag
                state.drag.active = true;
                
                // Determine start voxel
                if (state.tool === 'eraser' || e.button === 2) {
                    state.drag.start.set(hit.voxel.x, hit.voxel.y, hit.voxel.z);
                } else {
                    // Build mode starts adjacent
                    state.drag.start.set(
                        hit.voxel.x + (hit.pos.y > 0 ? hit.normal.x : 0), // Use normal if hitting block
                        hit.voxel.y + (hit.pos.y > 0 ? hit.normal.y : 0),
                        hit.voxel.z + (hit.pos.y > 0 ? hit.normal.z : 0)
                    );
                    // Correct ground logic
                    if(hit.pos.y < 0.1) state.drag.start.set(Math.floor(hit.pos.x), 0, Math.floor(hit.pos.z));
                }
            } else {
                // Brush Click
                if (state.tool === 'eraser' || e.button === 2) {
                    removeBlock(hit.voxel.x, hit.voxel.y, hit.voxel.z);
                } else {
                    const nx = hit.voxel.x + hit.normal.x;
                    const ny = hit.voxel.y + hit.normal.y;
                    const nz = hit.voxel.z + hit.normal.z;
                    // If hitting ground, just place at coords
                    if(hit.pos.y < 0.1) createBlock(Math.floor(hit.pos.x), 0, Math.floor(hit.pos.z), state.blockId);
                    else createBlock(nx, ny, nz, state.blockId);
                }
            }
        });

        document.addEventListener('mousemove', e => {
            if(state.mode === 'PLAY') {
                if(document.pointerLockElement) {
                    state.player.rot.y -= e.movementX * 0.002;
                    state.player.rot.x -= e.movementY * 0.002;
                    state.player.rot.x = Math.max(-1.5, Math.min(1.5, state.player.rot.x));
                    camera.quaternion.setFromEuler(state.player.rot);
                }
                return;
            }

            // Editor Logic
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            const hit = getIntersect();
            
            // Drag Preview
            if (state.drag.active && hit) {
                const end = new THREE.Vector3(hit.voxel.x, hit.voxel.y, hit.voxel.z);
                if(state.tool === 'box' && hit.pos.y > 0.1) end.add(hit.normal); // Add normal if building
                
                // Calculate Bounds
                const min = new THREE.Vector3().minVectors(state.drag.start, end);
                const max = new THREE.Vector3().maxVectors(state.drag.start, end).addScalar(1);
                
                const box = new THREE.Box3(min, max);
                selectionBox.box = box;
                selectionBox.visible = true;
                ghost.visible = false;
            } 
            // Ghost Cursor
            else if (hit) {
                selectionBox.visible = false;
                ghost.visible = true;
                
                if (state.tool === 'eraser') {
                    ghost.position.set(hit.voxel.x + 0.5, hit.voxel.y + 0.5, hit.voxel.z + 0.5);
                    ghost.material.color.setHex(0xff0000);
                } else {
                    // Place Preview
                    const pos = hit.pos.y < 0.1 
                        ? new THREE.Vector3(Math.floor(hit.pos.x)+0.5, 0.5, Math.floor(hit.pos.z)+0.5)
                        : new THREE.Vector3(hit.voxel.x + hit.normal.x + 0.5, hit.voxel.y + hit.normal.y + 0.5, hit.voxel.z + hit.normal.z + 0.5);
                    
                    ghost.position.copy(pos);
                    ghost.material.color.setHex(0x3b82f6);
                }
            } else {
                ghost.visible = false;
                selectionBox.visible = false;
            }
        });

        document.addEventListener('mouseup', () => {
            if (state.drag.active) {
                const box = selectionBox.box;
                if (box) {
                    for(let x = box.min.x; x < box.max.x; x++) {
                        for(let y = box.min.y; y < box.max.y; y++) {
                            for(let z = box.min.z; z < box.max.z; z++) {
                                if (state.tool === 'eraser') removeBlock(x,y,z);
                                else createBlock(x,y,z, state.blockId);
                            }
                        }
                    }
                }
                state.drag.active = false;
                selectionBox.visible = false;
            }
        });

        // --- GAME LOOP ---
        function updateGame() {
            // Entities (Enemies/Bullets)
            state.entities.forEach((e, i) => {
                if(e.type === 'enemy') {
                    const dir = new THREE.Vector3().subVectors(state.player.pos, e.pos).normalize();
                    e.pos.add(dir.multiplyScalar(0.05));
                    e.mesh.position.copy(e.pos);
                    e.mesh.lookAt(state.player.pos);
                    if(e.pos.distanceTo(state.player.pos) < 0.8) die();
                }
                if(e.type === 'bullet') {
                    e.pos.add(e.vel);
                    e.mesh.position.copy(e.pos);
                    if(e.pos.distanceTo(state.player.pos) < 0.8) die();
                    if(e.pos.distanceTo(state.player.pos) > 50) {
                        scene.remove(e.mesh);
                        state.entities.splice(i,1);
                    }
                }
            });

            // Turrets
            if (Math.random() < 0.01) {
                state.items.forEach(i => {
                    if(i.def.type === 'turret' && i.active) {
                        const p = new THREE.Vector3(i.x+0.5, i.y+0.5, i.z+0.5);
                        if(p.distanceTo(state.player.pos) < 15) {
                            const dir = new THREE.Vector3().subVectors(state.player.pos, p).normalize();
                            spawnBullet(p, dir);
                        }
                    }
                });
            }

            // Player Physics
            if(state.player.dead || state.player.won) return;
            const p = state.player;
            const speed = (state.keys.shift ? 0.3 : 0.15) * p.speed;
            
            const fwd = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(0,p.rot.y,0));
            const right = new THREE.Vector3(1,0,0).applyEuler(new THREE.Euler(0,p.rot.y,0));
            const move = new THREE.Vector3();
            
            if(state.keys.w) move.add(fwd);
            if(state.keys.s) move.sub(fwd);
            if(state.keys.d) move.add(right);
            if(state.keys.a) move.sub(right);
            if(move.length() > 0) move.normalize().multiplyScalar(speed);

            p.vel.x = move.x;
            p.vel.z = move.z;
            p.vel.y -= 0.015; // Gravity

            if(state.keys.space && p.onGround) { p.vel.y = 0.3; p.onGround = false; }

            // Collisions
            checkCollision(p);

            camera.position.copy(p.pos);
            camera.position.y += 1.6;
            
            // Check Items
            checkItems(p);
            
            if(p.pos.y < -20) die();
        }

        function checkCollision(p) {
            // Simple Axis Separation
            const axes = ['x', 'z', 'y'];
            axes.forEach(axis => {
                const testPos = p.pos.clone();
                if(axis === 'y') testPos.y += p.vel.y;
                else if(axis === 'x') testPos.x += p.vel.x;
                else testPos.z += p.vel.z;

                // Box Check
                const boxMin = new THREE.Vector3(testPos.x-0.3, testPos.y, testPos.z-0.3);
                const boxMax = new THREE.Vector3(testPos.x+0.3, testPos.y+1.8, testPos.z+0.3);
                
                let collide = false;
                // Check surrounding voxels
                for(let x=Math.floor(boxMin.x); x<=Math.ceil(boxMax.x); x++) {
                    for(let y=Math.floor(boxMin.y); y<=Math.ceil(boxMax.y); y++) {
                        for(let z=Math.floor(boxMin.z); z<=Math.ceil(boxMax.z); z++) {
                            const id = state.voxels[`${x},${y},${z}`];
                            if(id) {
                                const def = BLOCKS.find(b => b.id === id);
                                if(def.type === 'solid' || def.type === 'turret') collide = true;
                            }
                        }
                    }
                }
                
                if(collide) {
                    if(axis === 'y') {
                        if(p.vel.y < 0) p.onGround = true;
                        p.vel.y = 0;
                    }
                } else {
                    if(axis === 'y') { 
                        p.pos.y += p.vel.y;
                        p.onGround = false;
                    }
                    else if(axis === 'x') p.pos.x += p.vel.x;
                    else p.pos.z += p.vel.z;
                }
            });
            // Floor
            if(p.pos.y < 0) { p.pos.y = 0; p.onGround = true; p.vel.y = 0; }
        }

        function checkItems(p) {
            state.items.forEach(i => {
                if(!i.active) return;
                const dist = new THREE.Vector3(i.x+0.5, i.y+0.5, i.z+0.5).distanceTo(p.pos);
                if(dist < 1.0) {
                    if(i.def.type === 'coin') {
                        state.score += 100;
                        document.getElementById('score-val').innerText = state.score;
                        scene.remove(i.mesh);
                        i.active = false;
                    } else if(i.def.type === 'hazard') die();
                    else if(i.def.type === 'goal') win();
                    else if(i.def.type === 'jumppad') { p.vel.y = 0.8; p.onGround = false; }
                    else if(i.def.type === 'speedpad') { p.speed = 2.5; setTimeout(()=>p.speed=1, 2000); }
                }
            });
        }

        function spawnBullet(pos, dir) {
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.2), bulletMat);
            mesh.position.copy(pos);
            scene.add(mesh);
            state.entities.push({ type:'bullet', mesh, pos: pos.clone(), vel: dir.multiplyScalar(0.4) });
        }

        function spawnEnemy(pos) {
            const mesh = new THREE.Mesh(boxGeo, enemyMat);
            mesh.position.copy(pos);
            mesh.scale.set(0.8,0.8,0.8);
            scene.add(mesh);
            state.entities.push({ type:'enemy', mesh, pos });
        }

        function die() {
            state.player.dead = true;
            document.exitPointerLock();
            document.getElementById('game-overlay').classList.remove('hidden');
            document.getElementById('overlay-title').innerText = "GAME OVER";
            document.getElementById('overlay-title').className = "text-6xl font-black mb-4 text-red-500";
        }

        function win() {
            state.player.won = true;
            document.exitPointerLock();
            document.getElementById('game-overlay').classList.remove('hidden');
            document.getElementById('overlay-title').innerText = "VICTORY";
            document.getElementById('overlay-title').className = "text-6xl font-black mb-4 text-yellow-400";
        }

        function resetLevel() {
            state.player.dead = false;
            state.player.won = false;
            state.player.vel.set(0,0,0);
            state.score = 0;
            document.getElementById('score-val').innerText = "0";
            document.getElementById('game-overlay').classList.add('hidden');
            
            // Clear Dynamics
            state.entities.forEach(e => scene.remove(e.mesh));
            state.entities = [];
            
            // Respawn Items
            state.items.forEach(i => {
                if(!i.active && i.mesh) { scene.add(i.mesh); i.active = true; }
                if(i.def.type === 'enemy_spawner') spawnEnemy(new THREE.Vector3(i.x+0.5, i.y+1, i.z+0.5));
            });

            // Set Position
            let spawn = new THREE.Vector3(0,5,0);
            const spawnKey = Object.keys(state.voxels).find(k => state.voxels[k] === 10); // Start ID
            if(spawnKey) {
                const [x,y,z] = spawnKey.split(',').map(Number);
                spawn.set(x+0.5, y+2, z+0.5);
            }
            state.player.pos.copy(spawn);
        }

        function setMode(m) {
            state.mode = m;
            const editBtn = document.getElementById('modeEdit');
            const playBtn = document.getElementById('modePlay');
            
            if(m === 'EDIT') {
                editBtn.className = "px-3 py-1 text-xs font-bold rounded bg-blue-600 text-white shadow";
                playBtn.className = "px-3 py-1 text-xs font-bold rounded text-slate-400 hover:text-white";
                
                document.getElementById('score-display').classList.add('hidden');
                document.getElementById('crosshair').classList.add('hidden');
                document.getElementById('game-overlay').classList.add('hidden');
                document.exitPointerLock();
                ghost.visible = true;
                axesHelper.visible = true;
                gridHelper.visible = true;
            } else {
                playBtn.className = "px-3 py-1 text-xs font-bold rounded bg-blue-600 text-white shadow";
                editBtn.className = "px-3 py-1 text-xs font-bold rounded text-slate-400 hover:text-white";
                
                document.getElementById('score-display').classList.remove('hidden');
                document.getElementById('crosshair').classList.remove('hidden');
                ghost.visible = false;
                selectionBox.visible = false;
                axesHelper.visible = false;
                gridHelper.visible = false;
                
                resetLevel();
                document.body.requestPointerLock();
            }
        }

        document.addEventListener('keydown', e => {
            if(state.mode === 'PLAY') {
                if(e.code === 'KeyW') state.keys.w = true;
                if(e.code === 'KeyS') state.keys.s = true;
                if(e.code === 'KeyA') state.keys.a = true;
                if(e.code === 'KeyD') state.keys.d = true;
                if(e.code === 'Space') state.keys.space = true;
                if(e.code === 'ShiftLeft') state.keys.shift = true;
            } else {
                // Editor Fly
                const speed = e.shiftKey ? 1 : 0.5;
                const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
                if(e.code === 'KeyW') camera.position.add(fwd.multiplyScalar(speed));
                if(e.code === 'KeyS') camera.position.sub(fwd.multiplyScalar(speed));
                if(e.code === 'KeyD') camera.position.add(right.multiplyScalar(speed));
                if(e.code === 'KeyA') camera.position.sub(right.multiplyScalar(speed));
            }
        });
        document.addEventListener('keyup', e => {
            if(e.code === 'KeyW') state.keys.w = false;
            if(e.code === 'KeyS') state.keys.s = false;
            if(e.code === 'KeyA') state.keys.a = false;
            if(e.code === 'KeyD') state.keys.d = false;
            if(e.code === 'Space') state.keys.space = false;
            if(e.code === 'ShiftLeft') state.keys.shift = false;
        });
        
        // --- IO ---
        function saveWorld() {
            const blob = new Blob([JSON.stringify({voxels:state.voxels})], {type:'application/json'});
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download='world.json'; a.click();
        }
        function loadWorld(input) {
            const r = new FileReader(); r.onload = e => {
                const d = JSON.parse(e.target.result); clearWorld();
                Object.keys(d.voxels).forEach(k => { const [x,y,z] = k.split(',').map(Number); createBlock(x,y,z,d.voxels[k]); });
            }; r.readAsText(input.files[0]);
        }
        function publishGame() {
            let html = document.documentElement.outerHTML;
            html = html.replace('</head>', `<script>window.EXPORTED_WORLD=${JSON.stringify(state.voxels)}<\/script></head>`)
                       .replace('<body class="', '<body class="exported ');
            const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([html], {type:'text/html'})); a.download='GamerKraft_Pro.html'; a.click();
        }
        if(window.EXPORTED_WORLD) {
            Object.keys(window.EXPORTED_WORLD).forEach(k => { const [x,y,z] = k.split(',').map(Number); createBlock(x,y,z, window.EXPORTED_WORLD[k]); });
        }
        function startExportedGame() {
            document.getElementById('start-screen').style.display = 'none';
            setMode('PLAY');
        }

        // Loop
        lucide.createIcons();
        clearWorld();
        
        function animate() {
            requestAnimationFrame(animate);
            if(state.mode === 'PLAY') updateGame();
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
